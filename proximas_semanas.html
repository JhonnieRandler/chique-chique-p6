<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dashboard - Próximas Semanas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="main-container">
      <div class="card">
        <div class="flex flex-wrap justify-between items-center gap-4">
          <div>
            <h1 class="text-3xl font-bold text-gray-800 mb-2">
              Atividades das Próximas 6 Semanas
            </h1>
            <p id="grouping-info" class="text-gray-600">
              Carregando configuração de agrupamento...
            </p>
          </div>
          <div
            id="filter-controls"
            class="flex items-center gap-2 p-1 bg-gray-100 rounded-full"
          >
            <button class="filter-btn active" data-filter="all">Todos</button>
            <button class="filter-btn" data-filter="start">Início</button>
            <button class="filter-btn" data-filter="end">Fim</button>
            <button class="filter-btn" data-filter="ongoing">
              Em Andamento
            </button>
          </div>
        </div>
      </div>

      <div class="carousel-container">
        <div id="dashboard-output"></div>
        <button id="prev-btn" class="nav-button prev-btn">
          <svg
            class="w-6 h-6 text-gray-700"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15 19l-7-7 7-7"
            ></path>
          </svg>
        </button>
        <button id="next-btn" class="nav-button next-btn">
          <svg
            class="w-6 h-6 text-gray-700"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 5l7 7-7 7"
            ></path>
          </svg>
        </button>
      </div>
      <div id="week-indicators" class="week-indicators"></div>
    </div>

    <!-- App Scripts as a module -->
    <script type="module">
      import {
        initializationError,
        showFirebaseError,
      } from "./firebase-config.js";
      import * as utils from "./utils.js";

      // First, check if Firebase is configured. If not, show an error and stop.
      if (initializationError) {
        utils.insertHeader(); // Show nav so user isn't stuck
        showFirebaseError();
        throw initializationError; // Halt script execution
      }

      // If no error, import other modules and run the app
      import { storage } from "./storage.js";

      // ===== Page Script Starts Here =====
      utils.insertHeader();

      const dashboardOutput = document.getElementById("dashboard-output");
      const groupingInfo = document.getElementById("grouping-info");
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");
      const indicatorsContainer = document.getElementById("week-indicators");
      const filterControls = document.getElementById("filter-controls");

      let fullTaskList = [],
        weeksData = [],
        upcomingWeeks = [],
        wbsHierarchy = [],
        wbsMap = new Map(),
        activityMapping = [],
        activityStageMap = new Map(),
        customValuesData = new Map();
      let currentWeekIndex = 0;
      let groupedByWeek = {};
      let currentFilter = "all";

      (async () => {
        try {
          const projectBase = await storage.getProjectBase();
          const projectVersions = await storage.getProjectVersions();

          weeksData = await storage.getData(storage.APP_KEYS.WEEKS_DATA_KEY);
          activityMapping = await storage.getData(
            storage.APP_KEYS.ACTIVITY_MAPPING_KEY
          );
          const customValuesRaw = await storage.getData(
            storage.APP_KEYS.CUSTOM_VALUES_KEY
          );
          customValuesData = new Map(
            customValuesRaw.map((item) => [item.id, item])
          );

          if (!projectBase || Object.keys(projectBase).length === 0) {
            dashboardOutput.innerHTML = `<div class="message-box col-span-full">Nenhum projeto base encontrado. Faça o upload de um arquivo .xer.</div>`;
            return;
          }
          if (Object.keys(projectVersions).length === 0) {
            dashboardOutput.innerHTML = `<div class="message-box col-span-full">Nenhuma versão de projeto encontrada. Faça o upload de um arquivo .xer.</div>`;
            return;
          }
          if (weeksData.length === 0) {
            dashboardOutput.innerHTML = `<div class="message-box col-span-full">Nenhum mapeamento de semanas encontrado.</div>`;
            return;
          }

          // The full task list comes from the static base data.
          fullTaskList = projectBase.TASK?.rows || [];
          wbsHierarchy = projectBase.WBS_HIERARCHY?.rows || [];
          wbsMap = new Map(wbsHierarchy.map((w) => [w.stable_wbs_id, w]));

          const currentWeek = utils.getWeekForDate(new Date(), weeksData);
          if (currentWeek === null) {
            dashboardOutput.innerHTML = `<div class="message-box">Data atual fora do mapeamento.</div>`;
            return;
          }

          upcomingWeeks = Array.from(
            { length: 6 },
            (_, i) => currentWeek + 1 + i
          );

          fullTaskList.forEach(
            (task) =>
              (task.wbsPath = utils.getWbsPathObjects(
                task.wbs_stable_id_ref,
                wbsMap
              ))
          );
          activityMapping.forEach((group) => {
            const tasksInGroup = group.taskCodes
              .map((code) => fullTaskList.find((t) => t.task_code === code))
              .filter(Boolean);
            tasksInGroup.sort((a, b) => {
              const dateA = a.target_start_date
                ? new Date(a.target_start_date.replace(" ", "T"))
                : new Date("9999-12-31");
              const dateB = b.target_start_date
                ? new Date(b.target_start_date.replace(" ", "T"))
                : new Date("9999-12-31");
              return dateA - dateB;
            });
            tasksInGroup.forEach((task, index) => {
              activityStageMap.set(task.task_code, {
                groupName: group.groupName,
                stage: index + 1,
                totalStages: tasksInGroup.length,
              });
            });
          });

          await processAllWeeksData(projectBase, projectVersions);
          renderCurrentWeekView();
          setupNavigation();
        } catch (e) {
          console.error(e);
          dashboardOutput.innerHTML = `<div class="message-box" style="color: #b91c1c;">Erro: ${e.message}</div>`;
        }
      })();

      async function processAllWeeksData(projectBase, projectVersions) {
        let groupingLevels = await storage.getData(
          storage.APP_KEYS.WEEKS_VIEW_GROUPING_KEY
        );
        const hiddenActivities = await storage.getData(
          storage.APP_KEYS.WEEKS_VIEW_HIDDEN_ACTIVITIES_KEY
        );

        if (!groupingLevels || groupingLevels.length === 0) {
          const maxLevel = Math.max(
            0,
            ...wbsHierarchy.map((w) => parseInt(w.level, 10))
          );
          groupingLevels = Array.from({ length: maxLevel }, (_, i) => i + 1);
          groupingInfo.textContent =
            "Agrupando por hierarquia completa (padrão).";
        } else {
          groupingInfo.innerHTML = `Agrupando por: <strong>${groupingLevels
            .map((l) => `Nível ${l}`)
            .join(
              " &rarr; "
            )}</strong>. <a href="configuracao.html" class="text-blue-600 hover:underline">Alterar</a>`;
        }

        // We now use the static fullTaskList from projectBase for filtering.
        const tasksToProcess = fullTaskList.filter((task) => {
          if (
            task.status_code === "TK_Complete" ||
            hiddenActivities.includes(task.task_code)
          )
            return false;
          const startDateStr = task.act_start_date || task.restart_date;
          const endDateStr = task.reend_date || task.target_end_date;
          if (!startDateStr || !endDateStr) return false;
          const startWeek = utils.getWeekForDate(
            startDateStr.replace(" ", "T"),
            weeksData
          );
          const endWeek = utils.getWeekForDate(
            endDateStr.replace(" ", "T"),
            weeksData
          );
          if (startWeek === null || endWeek === null || endWeek < startWeek)
            return false;
          return upcomingWeeks.some((w) => w >= startWeek && w <= endWeek);
        });
        upcomingWeeks.forEach((w) => (groupedByWeek[w] = {}));
        tasksToProcess.forEach((task) => {
          const startDate = new Date(
            (task.act_start_date || task.restart_date).replace(" ", "T")
          );
          const endDate = new Date(
            (task.reend_date || task.target_end_date).replace(" ", "T")
          );
          const startWeek = utils.getWeekForDate(startDate, weeksData);
          const endWeek = utils.getWeekForDate(endDate, weeksData);
          for (let weekNum = startWeek; weekNum <= endWeek; weekNum++) {
            if (upcomingWeeks.includes(weekNum)) {
              let tag = weekNum === startWeek ? "Início" : "";
              if (weekNum === endWeek) tag = tag ? "Início e Fim" : "Fim";
              const groupName = activityStageMap.get(task.task_code)?.groupName;
              const item = groupName
                ? { type: "group", groupName, task: { ...task, tag } }
                : { type: "task", task: { ...task, tag } };
              buildGroupedTreeRecursive(
                item,
                groupingLevels,
                groupedByWeek[weekNum]
              );
            }
          }
        });
      }

      function buildGroupedTreeRecursive(item, levels, currentTree) {
        const { type, task, groupName } = item;
        const [currentLevelToGroup, ...remainingLevels] = levels;
        if (!currentLevelToGroup) return;
        const wbsNodeAtLevel = task.wbsPath.find(
          (p) => p.level == currentLevelToGroup
        );
        if (!wbsNodeAtLevel) {
          const closestParentNode =
            task.wbsPath.length > 0
              ? task.wbsPath[task.wbsPath.length - 1]
              : { wbs_name: "(Sem WBS)", stable_wbs_id: "(Sem WBS)" };
          const groupKey = closestParentNode.stable_wbs_id;
          if (!currentTree[groupKey])
            currentTree[groupKey] = {
              data: closestParentNode,
              children: {},
              items: new Map(),
            };
          const itemKey = type === "group" ? groupName : task.task_code;
          if (!currentTree[groupKey].items.has(itemKey))
            currentTree[groupKey].items.set(itemKey, {
              type,
              data: type === "group" ? { groupName } : task,
              relatedTasks: [],
            });
          currentTree[groupKey].items.get(itemKey).relatedTasks.push(task);
          return;
        }
        const groupKey = wbsNodeAtLevel.stable_wbs_id;
        if (!currentTree[groupKey])
          currentTree[groupKey] = {
            data: wbsNodeAtLevel,
            children: {},
            items: new Map(),
          };
        if (remainingLevels.length === 0) {
          const itemKey = type === "group" ? groupName : task.task_code;
          if (!currentTree[groupKey].items.has(itemKey))
            currentTree[groupKey].items.set(itemKey, {
              type,
              data: type === "group" ? { groupName } : task,
              relatedTasks: [],
            });
          currentTree[groupKey].items.get(itemKey).relatedTasks.push(task);
        } else {
          buildGroupedTreeRecursive(
            item,
            remainingLevels,
            currentTree[groupKey].children
          );
        }
      }

      function itemMatchesFilter(item) {
        if (currentFilter === "all") return true;
        if (item.type === "group") {
          return item.relatedTasks.some((task) => {
            const tag = task.tag || "";
            if (currentFilter === "start") return tag.includes("Início");
            if (currentFilter === "end") return tag.includes("Fim");
            if (currentFilter === "ongoing") return tag === "";
            return false;
          });
        }
        const tag = item.relatedTasks[0].tag || "";
        if (currentFilter === "start") return tag.includes("Início");
        if (currentFilter === "end") return tag.includes("Fim");
        if (currentFilter === "ongoing") return tag === "";
        return false;
      }

      function renderCurrentWeekView() {
        const weekNumber = upcomingWeeks[currentWeekIndex];
        const weekTree = { children: groupedByWeek[weekNumber] || {} };
        const weekInfo = weeksData.find(
          (w) => parseInt(w.Semana, 10) === weekNumber
        );
        const dateRange = weekInfo
          ? `(${utils.formatBrazilianDate(
              weekInfo.Data_Inicio
            )} - ${utils.formatBrazilianDate(weekInfo.Data_Fim)})`
          : "";

        let hasContent = false;

        const renderNode = (node) => {
          let html = "";
          const sortedChildrenKeys = Object.keys(node.children).sort((a, b) =>
            node.children[a].data.wbs_name.localeCompare(
              node.children[b].data.wbs_name
            )
          );

          sortedChildrenKeys.forEach((key) => {
            const childNode = node.children[key];
            const filteredItems = Array.from(childNode.items.values()).filter(
              itemMatchesFilter
            );
            const childrenHtml = renderNode(childNode);
            if (filteredItems.length === 0 && childrenHtml === "") return;
            html += `<div class="wbs-group"><h4 class="wbs-title"><span>${childNode.data.wbs_name}</span><span class="wbs-toggle text-xl text-gray-500 font-mono cursor-pointer">+</span></h4><div class="wbs-content">`;
            if (filteredItems.length > 0) {
              html += '<div class="item-list">';
              filteredItems.forEach((item) => {
                hasContent = true;
                let tagHtml = "";
                let tooltipHtml = "";
                let itemEntryClass = "item-entry";

                if (item.type === "group") {
                  const { groupName, totalStages } = activityStageMap.get(
                    item.relatedTasks[0].task_code
                  );
                  const groupId = `group::${groupName}`;
                  const customValue = customValuesData.get(groupId);

                  if (customValue) {
                    const remaining =
                      (customValue.planned || 0) - (customValue.actual || 0);
                    tooltipHtml = `data-tooltip="Saldo Topográfico: ${utils.formatNumberBR(
                      remaining
                    )}"`;
                    itemEntryClass += " tooltip has-tooltip";
                  }

                  const stagesInWeek = item.relatedTasks
                    .map((t) => activityStageMap.get(t.task_code).stage)
                    .sort((a, b) => a - b);
                  const startsInWeek = item.relatedTasks.some((t) =>
                    t.tag.includes("Início")
                  );
                  const endsInWeek = item.relatedTasks.some((t) =>
                    t.tag.includes("Fim")
                  );
                  if (startsInWeek)
                    tagHtml += `<span class="tag tag-start">Início</span>`;
                  if (endsInWeek)
                    tagHtml += `<span class="tag tag-end">Fim</span>`;
                  const stageText =
                    stagesInWeek.length > 1
                      ? `Etapas ${stagesInWeek.join(", ")}`
                      : `Etapa ${stagesInWeek[0]}`;
                  html += `<div class="${itemEntryClass}" ${tooltipHtml}><div class="flex justify-between items-center"><p class="font-semibold text-gray-700">${groupName}</p><div>${tagHtml}</div></div><p class="text-sm text-gray-500 italic">${stageText} de ${totalStages}</p></div>`;
                } else {
                  const task = item.relatedTasks[0];
                  const customValue = customValuesData.get(task.task_code);

                  if (customValue) {
                    const remaining =
                      (customValue.planned || 0) - (customValue.actual || 0);
                    tooltipHtml = `data-tooltip="Saldo Topográfico: ${utils.formatNumberBR(
                      remaining
                    )}"`;
                    itemEntryClass += " tooltip has-tooltip";
                  }

                  if (task.tag.includes("Início"))
                    tagHtml += `<span class="tag tag-start">Início</span>`;
                  if (task.tag.includes("Fim"))
                    tagHtml += `<span class="tag tag-end">Fim</span>`;
                  html += `<div class="${itemEntryClass}" ${tooltipHtml}><div class="flex justify-between items-center"><p class="font-semibold text-gray-700">${task.task_code}</p><div>${tagHtml}</div></div><p class="text-sm text-gray-600">${task.task_name}</p></div>`;
                }
              });
              html += "</div>";
            }
            html += childrenHtml;
            html += `</div></div>`;
          });
          return html;
        };

        let weekContent = renderNode(weekTree);
        if (!hasContent) {
          weekContent = `<p class="text-lg text-gray-500 italic py-20 text-center">Nenhuma atividade para o filtro "${currentFilter}" nesta semana.</p>`;
        }

        dashboardOutput.innerHTML = `
            <div class="week-card">
              <div class="week-card-header">
                  <h3>
                    <span>Semana ${weekNumber}</span> 
                    <span class="text-lg font-normal text-gray-500">(${
                      currentWeekIndex + 1
                    }ª de 6)</span>
                    <span class="text-base font-normal text-gray-500 ml-4">${dateRange}</span>
                  </h3>
                  <button id="toggle-all-btn" data-state="collapsed" class="text-sm font-medium text-blue-600 hover:text-blue-800 p-2 rounded-md hover:bg-blue-50 transition-colors">Expandir Tudo</button>
              </div>
              ${weekContent}
            </div>`;

        document.querySelectorAll(".wbs-content").forEach((content) => {
          content.style.maxHeight = "0px";
        });

        document
          .getElementById("toggle-all-btn")
          ?.addEventListener("click", toggleAllWbs);
        updateNavigation();
      }

      function toggleAllWbs(event) {
        const btn = event.target;
        const isExpanding = btn.dataset.state === "collapsed";
        const allContentElements = Array.from(
          dashboardOutput.querySelectorAll(".wbs-content")
        );

        if (isExpanding) {
          // Expand from the inside out to calculate scrollHeight correctly.
          [...allContentElements].reverse().forEach((content) => {
            const icon =
              content.previousElementSibling.querySelector(".wbs-toggle");
            if (icon) icon.textContent = "-";
            content.classList.add("expanded");
            content.style.maxHeight = content.scrollHeight + "px";
          });
        } else {
          // Collapse any order.
          allContentElements.forEach((content) => {
            const icon =
              content.previousElementSibling.querySelector(".wbs-toggle");
            if (content.classList.contains("expanded")) {
              // Set height explicitly to start transition, then set to 0.
              content.style.maxHeight = content.scrollHeight + "px";
              requestAnimationFrame(() => {
                content.classList.remove("expanded");
                content.style.maxHeight = "0px";
                if (icon) icon.textContent = "+";
              });
            }
          });
        }

        btn.dataset.state = isExpanding ? "expanded" : "collapsed";
        btn.textContent = isExpanding ? "Minimizar Tudo" : "Expandir Tudo";
      }

      function setupNavigation() {
        prevBtn.addEventListener("click", () => {
          if (currentWeekIndex > 0) {
            currentWeekIndex--;
            renderCurrentWeekView();
          }
        });
        nextBtn.addEventListener("click", () => {
          if (currentWeekIndex < upcomingWeeks.length - 1) {
            currentWeekIndex++;
            renderCurrentWeekView();
          }
        });

        indicatorsContainer.innerHTML = upcomingWeeks
          .map(
            (_, i) => `<span class="indicator-dot" data-index="${i}"></span>`
          )
          .join("");
        indicatorsContainer
          .querySelectorAll(".indicator-dot")
          .forEach((dot) => {
            dot.addEventListener("click", () => {
              currentWeekIndex = parseInt(dot.dataset.index);
              renderCurrentWeekView();
            });
          });

        // Listener for Toggling Individual Items
        dashboardOutput.addEventListener("click", (e) => {
          const toggleTitle = e.target.closest(".wbs-title");
          if (!toggleTitle) return;

          const content = toggleTitle.nextElementSibling;
          const icon = toggleTitle.querySelector(".wbs-toggle");
          if (!content || !content.classList.contains("wbs-content")) return;

          const isExpanded = content.classList.contains("expanded");

          if (isExpanded) {
            // To collapse: Set max-height from 'none' or current px value to its current pixel height.
            // This gives the CSS transition a defined starting value.
            content.style.maxHeight = content.scrollHeight + "px";

            // In the next frame, set max-height to 0 to start the collapse animation.
            requestAnimationFrame(() => {
              content.classList.remove("expanded");
              content.style.maxHeight = "0px";
              if (icon) icon.textContent = "+";
            });
          } else {
            // To expand: Add the class and set max-height to its scrollHeight.
            content.classList.add("expanded");
            if (icon) icon.textContent = "-";
            content.style.maxHeight = content.scrollHeight + "px";
          }
        });

        // Listener for cleaning up after transitions and updating parents.
        dashboardOutput.addEventListener("transitionend", (e) => {
          const content = e.target;

          // Ensure we're dealing with the right element and property
          if (
            !content.classList.contains("wbs-content") ||
            e.propertyName !== "max-height"
          ) {
            return;
          }

          // After an animation, find the parent and update its height
          const parent = content.parentElement.closest(".wbs-content.expanded");
          if (parent) {
            // If the parent is expanded, its scrollHeight has now changed.
            // Re-set its max-height to its new scrollHeight to animate the change.
            // The 'none' setting will be applied when the PARENT'S transition ends,
            // creating a chain reaction.
            parent.style.maxHeight = parent.scrollHeight + "px";
          }

          // After dealing with the parent, finalize the state of the current element.
          // If it has finished expanding (is not collapsed), set max-height to 'none'
          // so it can auto-resize if ITS children change later.
          if (content.style.maxHeight !== "0px") {
            content.style.maxHeight = "none";
          }
        });

        filterControls.addEventListener("click", (e) => {
          if (e.target.matches(".filter-btn")) {
            filterControls.querySelector(".active").classList.remove("active");
            e.target.classList.add("active");
            currentFilter = e.target.dataset.filter;
            renderCurrentWeekView();
          }
        });
      }

      function updateNavigation() {
        prevBtn.disabled = currentWeekIndex === 0;
        nextBtn.disabled = currentWeekIndex === upcomingWeeks.length - 1;
        indicatorsContainer
          .querySelectorAll(".indicator-dot")
          .forEach((dot, index) => {
            dot.classList.toggle("active", index === currentWeekIndex);
          });
      }
    </script>
  </body>
</html>
