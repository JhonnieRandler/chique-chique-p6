<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Acompanhamento de Projetos P6</title>
    <!-- Incluindo Tailwind CSS para estilização fácil e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="container" id="index-container">
      <h1 class="text-4xl font-bold text-gray-800 mb-6">Painel de Controle</h1>
      <p class="text-gray-600 mb-8">
        Envie seu arquivo .xer do Primavera P6 para carregar ou atualizar as
        informações do projeto.
      </p>

      <div id="drop-area" class="drop-area">
        <p class="text-xl text-gray-500 mb-4">
          Arraste e solte o arquivo .xer aqui
        </p>
        <p class="text-gray-400 mb-4">- OU -</p>
        <label for="fileElem" class="file-input-label"
          >Selecionar Arquivo</label
        >
        <input type="file" id="fileElem" accept=".xer" />
      </div>

      <div id="file-display" class="file-info hidden">
        Último arquivo processado:
        <span id="file-name" class="font-semibold text-gray-700"></span>
      </div>

      <section id="dashboard-section" class="dashboard-section">
        <div id="dashboard-output">
          <p class="message-box info">
            Nenhuma informação de projeto carregada ainda. Por favor, envie um
            arquivo .xer.
          </p>
        </div>
      </section>
    </div>

    <script src="storage.js"></script>
    <script src="utils.js"></script>
    <script>
      insertHeader();

      const dropArea = document.getElementById("drop-area");
      const fileElem = document.getElementById("fileElem");
      const fileDisplay = document.getElementById("file-display");
      const fileNameSpan = document.getElementById("file-name");
      const dashboardOutput = document.getElementById("dashboard-output");

      const OVERWRITE_TABLE_NAMES = [
        "PROJECT",
        "RSRC",
        "TASK",
        "TASKPRED",
        "ACTVCODE",
        "TASKACTV",
        "PROJWBS",
        "WBS_HIERARCHY",
      ];

      const COLUMNS_TO_SAVE_MAP = {
        PROJECT: [
          "proj_id",
          "proj_name",
          "last_recalc_date",
          "plan_start_date",
          "scd_end_date",
        ],
        RSRC: ["rsrc_name", "rsrc_type"],
        TASK: [
          "status_code",
          "task_code",
          "task_name",
          "target_equip_qty",
          "act_equip_qty",
          "remain_equip_qty",
          "act_start_date",
          "act_end_date",
          "reend_date",
          "restart_date",
          "target_start_date",
          "target_end_date",
          "wbs_stable_id_ref",
        ],
        TASKPRED: [
          "task_id_code",
          "pred_task_id_code",
          "pred_type",
          "lag_hr_cnt",
        ],
        TASKRSRC: [
          "proj_id",
          "remain_qty",
          "target_qty",
          "act_reg_qty",
          "rsrc_type",
          "task_id_code",
          "rsrc_id_name",
        ],
        PROJWBS: ["wbs_id", "wbs_name", "parent_wbs_id"],
        WBS_HIERARCHY: [
          "stable_wbs_id",
          "wbs_name",
          "wbs_group_id",
          "level",
          "parent_stable_wbs_id",
        ],
        ACTVCODE: ["actv_code_name", "parent_actv_code_name"],
        TASKACTV: ["task_id_code", "actv_code_id_name"],
      };

      ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        dropArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      ["dragenter", "dragover"].forEach((eventName) =>
        dropArea.addEventListener(eventName, highlight, false)
      );
      ["dragleave", "drop"].forEach((eventName) =>
        dropArea.addEventListener(eventName, unhighlight, false)
      );
      function highlight() {
        dropArea.classList.add("highlight");
      }
      function unhighlight() {
        dropArea.classList.remove("highlight");
      }
      dropArea.addEventListener("drop", handleDrop, false);
      function handleDrop(e) {
        handleFiles(e.dataTransfer.files);
      }
      fileElem.addEventListener("change", function (e) {
        handleFiles(e.target.files);
      });

      async function handleFiles(files) {
        if (files.length === 0) return;
        const file = files[0];
        if (!file.name.toLowerCase().endsWith(".xer")) {
          dashboardOutput.innerHTML = `<p class="message-box error">Por favor, selecione um arquivo com a extensão .xer.</p>`;
          return;
        }
        fileNameSpan.textContent = file.name;
        fileDisplay.classList.remove("hidden");
        dashboardOutput.innerHTML = `<p class="message-box info">Processando e salvando arquivo... Isso pode levar alguns instantes.</p>`;

        const reader = new FileReader();
        reader.onload = async function (e) {
          try {
            const fileContent = e.target.result;
            const parsedTables = parseXER(fileContent);
            const currentProjectId =
              parsedTables["PROJECT"]?.rows[0]?.proj_id || `UNK_${Date.now()}`;
            const transformedTables = transformData(
              parsedTables,
              currentProjectId
            );

            let allProjectsData = storage.getData(
              storage.APP_KEYS.PROJECTS_DATA_KEY
            );
            let allTaskRsrcData = storage.getData(
              storage.APP_KEYS.TASKRSRC_DATA_KEY
            );

            const currentProjectVersionTables = {};
            OVERWRITE_TABLE_NAMES.forEach((tableName) => {
              if (transformedTables[tableName]) {
                currentProjectVersionTables[tableName] = filterTableColumns(
                  transformedTables[tableName],
                  COLUMNS_TO_SAVE_MAP[tableName]
                );
              }
            });

            allProjectsData[currentProjectId] = currentProjectVersionTables;

            if (transformedTables["TASKRSRC"]?.rows.length > 0) {
              allTaskRsrcData = allTaskRsrcData.filter(
                (item) => item.proj_id !== currentProjectId
              );
              const filteredTaskRsrcRows = filterRowsByColumns(
                transformedTables["TASKRSRC"].rows,
                COLUMNS_TO_SAVE_MAP["TASKRSRC"]
              );
              allTaskRsrcData.push(...filteredTaskRsrcRows);
            }

            storage.saveData(
              storage.APP_KEYS.PROJECTS_DATA_KEY,
              allProjectsData
            );
            storage.saveData(
              storage.APP_KEYS.TASKRSRC_DATA_KEY,
              allTaskRsrcData
            );

            loadDashboard();
          } catch (error) {
            console.error("Erro ao processar ou salvar o arquivo:", error);
            dashboardOutput.innerHTML = `<p class="message-box error">Erro ao processar o arquivo: ${error.message}.</p>`;
          }
        };
        reader.readAsText(file, "ISO-8859-1");
      }

      function parseXER(xerContent) {
        const lines = xerContent.split(/\r?\n/);
        const tables = {};
        let currentTableName = null;
        let currentTableHeaders = [];
        for (const line of lines) {
          const trimmedLine = line.trim();
          if (trimmedLine.startsWith("%T")) {
            currentTableName = trimmedLine.substring(2).trim();
            tables[currentTableName] = { headers: [], rows: [] };
          } else if (trimmedLine.startsWith("%F") && currentTableName) {
            currentTableHeaders = trimmedLine
              .substring(2)
              .split("\t")
              .map((h) => h.trim())
              .filter((h) => h.length > 0);
            tables[currentTableName].headers = currentTableHeaders;
          } else if (
            trimmedLine.startsWith("%R") &&
            currentTableName &&
            currentTableHeaders.length > 0
          ) {
            const values = trimmedLine.substring(2).trimStart().split("\t");
            const rowObject = {};
            currentTableHeaders.forEach((header, i) => {
              rowObject[header] = values[i]?.trim() || "";
            });
            tables[currentTableName].rows.push(rowObject);
          }
        }
        return tables;
      }

      function transformData(parsedTables, currentProjectId) {
        const transformed = JSON.parse(JSON.stringify(parsedTables));

        const wbsData = transformed.PROJWBS?.rows || [];
        const wbsMap = new Map(wbsData.map((wbs) => [wbs.wbs_id, wbs]));
        const hierarchyData = [];
        const originalToStableIdMap = new Map();
        const levelCache = new Map();

        wbsData.forEach((wbs) => {
          let path = [wbs.wbs_name];
          let current = wbs;
          while (current.parent_wbs_id && wbsMap.has(current.parent_wbs_id)) {
            current = wbsMap.get(current.parent_wbs_id);
            path.unshift(current.wbs_name);
          }
          const stableId = path.join(" > ");
          originalToStableIdMap.set(wbs.wbs_id, stableId);
        });

        function getWbsLevel(wbsId) {
          if (levelCache.has(wbsId)) return levelCache.get(wbsId);
          const wbs = wbsMap.get(wbsId);
          if (!wbs || !wbs.parent_wbs_id || !wbsMap.has(wbs.parent_wbs_id)) {
            levelCache.set(wbsId, 1);
            return 1;
          }
          const parentLevel = getWbsLevel(wbs.parent_wbs_id);
          const currentLevel = parentLevel + 1;
          levelCache.set(wbsId, currentLevel);
          return currentLevel;
        }

        const rootWbs = wbsData.find(
          (w) => !w.parent_wbs_id || !wbsMap.has(w.parent_wbs_id)
        );
        const rootWbsStableId = rootWbs
          ? originalToStableIdMap.get(rootWbs.wbs_id)
          : null;

        wbsData.forEach((wbs) => {
          if (originalToStableIdMap.get(wbs.wbs_id) === rootWbsStableId) return;
          hierarchyData.push({
            stable_wbs_id: originalToStableIdMap.get(wbs.wbs_id),
            wbs_name: wbs.wbs_name,
            level: getWbsLevel(wbs.wbs_id) - 1,
            parent_stable_wbs_id:
              originalToStableIdMap.get(wbs.parent_wbs_id) === rootWbsStableId
                ? null
                : originalToStableIdMap.get(wbs.parent_wbs_id),
          });
        });

        transformed["WBS_HIERARCHY"] = {
          headers: [
            "stable_wbs_id",
            "wbs_name",
            "level",
            "parent_stable_wbs_id",
          ],
          rows: hierarchyData,
        };

        const rsrcIdToNameMap = new Map(
          transformed.RSRC?.rows.map((r) => [r.rsrc_id, r.rsrc_name])
        );
        const taskIdToCodeMap = new Map(
          transformed.TASK?.rows.map((t) => [t.task_id, t.task_code])
        );
        const actvCodeIdToNameMap = new Map(
          transformed.ACTVCODE?.rows.map((c) => [
            c.actv_code_id,
            c.actv_code_name,
          ])
        );

        if (transformed.TASK) {
          transformed.TASK.rows.forEach((task) => {
            task.wbs_stable_id_ref =
              originalToStableIdMap.get(task.wbs_id) || null;
            task.act_start_date =
              task.act_start_date || task.actual_start_dt || "";
            task.act_end_date = task.act_end_date || task.actual_end_dt || "";
            task.target_start_date =
              task.target_start_date || task.target_start_dt || "";
            task.target_end_date =
              task.target_end_date || task.target_end_dt || "";
            task.restart_date = task.restart_date || "";
            task.reend_date = task.reend_date || "";
          });
          const newHeaders = [
            "wbs_stable_id_ref",
            "act_start_date",
            "act_end_date",
            "restart_date",
            "reend_date",
            "target_start_date",
            "target_end_date",
          ];
          newHeaders.forEach(
            (h) =>
              !transformed.TASK.headers.includes(h) &&
              transformed.TASK.headers.push(h)
          );
        }

        if (transformed.TASKPRED) {
          transformed.TASKPRED.rows.forEach((pred) => {
            pred.task_id_code =
              taskIdToCodeMap.get(pred.task_id) || pred.task_id;
            pred.pred_task_id_code =
              taskIdToCodeMap.get(pred.pred_task_id) || pred.pred_task_id;
          });
          if (!transformed.TASKPRED.headers.includes("task_id_code")) {
            transformed.TASKPRED.headers.push("task_id_code");
          }
          if (!transformed.TASKPRED.headers.includes("pred_task_id_code")) {
            transformed.TASKPRED.headers.push("pred_task_id_code");
          }
        }
        if (transformed.TASKRSRC) {
          transformed.TASKRSRC.rows.forEach((taskrsrc) => {
            taskrsrc.task_id_code =
              taskIdToCodeMap.get(taskrsrc.task_id) || taskrsrc.task_id;
            taskrsrc.rsrc_id_name =
              rsrcIdToNameMap.get(taskrsrc.rsrc_id) || taskrsrc.rsrc_id;
            taskrsrc.proj_id = currentProjectId;
          });
          if (!transformed.TASKRSRC.headers.includes("task_id_code")) {
            transformed.TASKRSRC.headers.push("task_id_code");
          }
          if (!transformed.TASKRSRC.headers.includes("rsrc_id_name")) {
            transformed.TASKRSRC.headers.push("rsrc_id_name");
          }
          if (!transformed.TASKRSRC.headers.includes("proj_id")) {
            transformed.TASKRSRC.headers.push("proj_id");
          }
        }
        if (transformed.ACTVCODE) {
          transformed.ACTVCODE.rows.forEach((code) => {
            code.parent_actv_code_name =
              actvCodeIdToNameMap.get(code.parent_actv_code_id) || "";
          });
          if (!transformed.ACTVCODE.headers.includes("parent_actv_code_name")) {
            transformed.ACTVCODE.headers.push("parent_actv_code_name");
          }
        }
        if (transformed.TASKACTV) {
          transformed.TASKACTV.rows.forEach((taskactv) => {
            taskactv.task_id_code =
              taskIdToCodeMap.get(taskactv.task_id) || taskactv.task_id;
            taskactv.actv_code_id_name =
              actvCodeIdToNameMap.get(taskactv.actv_code_id) ||
              taskactv.actv_code_id;
          });
          if (!transformed.TASKACTV.headers.includes("task_id_code")) {
            transformed.TASKACTV.headers.push("task_id_code");
          }
          if (!transformed.TASKACTV.headers.includes("actv_code_id_name")) {
            transformed.TASKACTV.headers.push("actv_code_id_name");
          }
        }
        return transformed;
      }

      function filterTableColumns(tableData, columnsToKeep) {
        if (!tableData?.rows || !columnsToKeep)
          return { headers: [], rows: [] };
        const newHeaders = columnsToKeep.filter((header) =>
          tableData.headers.includes(header)
        );
        const newRows = tableData.rows.map((row) => {
          const newRow = {};
          newHeaders.forEach((header) => {
            newRow[header] = row[header] ?? "";
          });
          return newRow;
        });
        return { headers: newHeaders, rows: newRows };
      }

      function filterRowsByColumns(rows, columnsToKeep) {
        if (!rows || !columnsToKeep) return [];
        return rows.map((row) => {
          const newRow = {};
          columnsToKeep.forEach((header) => {
            if (row.hasOwnProperty(header)) {
              newRow[header] = row[header];
            }
          });
          return newRow;
        });
      }

      function displayDashboard(allProjectsData, weeksMapping) {
        let projectsListHtml = Object.keys(allProjectsData)
          .map((projId) => {
            const projectInfo = allProjectsData[projId]?.PROJECT?.rows[0];
            if (!projectInfo) return "";
            const recalcDate = projectInfo.last_recalc_date;
            const weekNumber = getWeekForDate(recalcDate, weeksMapping);
            const weekText = weekNumber
              ? `Semana ${weekNumber}`
              : "Semana não mapeada";

            return `
            <div class="project-list-item">
              <div class="font-medium text-gray-800">${weekText} <span class="text-xs text-gray-500 font-mono ml-2">(${projId})</span></div>
              <div class="text-gray-600">Atualizado em: ${formatBrazilianDate(
                recalcDate
              )}</div>
            </div>`;
          })
          .join("");

        dashboardOutput.innerHTML = `
            <div>
              <h2 class="text-2xl font-bold text-gray-800 mb-4">Projetos Carregados</h2>
              <div class="space-y-2">${projectsListHtml}</div>
            </div>
        `;
      }

      function loadDashboard() {
        try {
          const allProjectsData = storage.getData(
            storage.APP_KEYS.PROJECTS_DATA_KEY
          );
          const weeksMapping = storage.getData(storage.APP_KEYS.WEEKS_DATA_KEY);

          const projectIds = Object.keys(allProjectsData);
          if (projectIds.length > 0) {
            displayDashboard(allProjectsData, weeksMapping);
            fileDisplay.classList.remove("hidden");
            if (!fileNameSpan.textContent) {
              fileNameSpan.textContent =
                "Dados carregados do armazenamento local.";
            }
          } else {
            dashboardOutput.innerHTML = `
              <div>
                <p class="message-box info">Nenhuma informação de projeto carregada. Por favor, envie um arquivo .xer.</p>
              </div>
            `;
          }
        } catch (error) {
          console.error("Erro ao carregar o dashboard:", error);
          dashboardOutput.innerHTML = `<p class="message-box error">Ocorreu um erro ao carregar o dashboard: ${error.message}.</p>`;
        }
      }

      loadDashboard();
    </script>
  </body>
</html>
